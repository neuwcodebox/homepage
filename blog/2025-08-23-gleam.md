# Gleam

[Gleam](https://gleam.run/)이란 언어를 찾았다. 이름만 들어봤던 얼랭, 엘릭서 언어들에 뿌리를 둔 언어란다.
이 두 언어에 대해서는 사실 잘 모른다. Gleam만 살짝 맛보고 적어보는 글.

<!-- truncate -->

하스켈이라던가 함수형 언어는 사실 그렇게 취향은 아니지만 Gleam의 아이콘이 귀여워서 눈길이 갔다.

![](/attachments/blog/2025-08-23-gleam/file-20250823154042104.png)

[공식 사이트](https://tour.gleam.run/)에 투어 형식의 자료가 있어서 한번 쭉 봤고 기억에 남는 거 위주로 적어본다.

일단 첫인상은 Rust 느낌이 났다. 언어의 철학이라던가 잘 모르지만 그냥 내가 기존에 알던 언어 중에는 Rust를 가장 닮았다.

```gleam
import gleam/io

pub fn main() {
  io.println("Hello, Joe!")
}
```

pub, fn, println 이것만 봐도...

그리고 특이했던 건 Int, Float 연산자가 다르다는 것.
Int는 그냥 `+, -, >, <` 하면 되는데 Float는 `+., -., >., <.` 이렇게 점을 붙여야 한다.
번외로 String은 `"A" <> "B"` 하면 `"AB"`로 붙는다.
솔직히 그렇게 마음에 드는 문법은 아님...

또 신박했던 건 Rust에서 처음 봤던 블럭 표현식을 더 적극적으로 연산 우선순위 지정할 때에도 쓰는 거였음.
단순히 쓰는 것 뿐 아니라 애초에 소괄호로 우선순위 설정하는 문법 자체가 없음.

```gleam
let a = { 1 + 2 } / 3 // OK
let b = (1 + 2) / 3 // Error!
```

제너릭도 있는데 제너릭 타입을 따로 선언하는 방식이 아니라 그냥 타입이 들어갈 곳에 소문자로 쓰면 그게 제너릭 타입이 되는 건 좀 신기했다.

함수형 언어답게 불변성을 중요시 한다.
변?수는 선언할 때에만 값을 담을 수 있고 바꾸는 건 오직 같은 이름으로 다시 선언하는 방법 뿐이다.
물론 바꾸는 게 아니라 일종의 쉐도잉.
let, const 키워드가 있지만 둘 다 불변이고 차이점은 const는 전역 상수 전용이라는 것.

함수 관련 문법도 꽤 있다.
파라미터 하나를 받아서 그걸로 어떤 함수를 바로 호출하기만 하는 익명 함수의 경우 다음과 같이 할 수 있다.

```gleam
let a = fn(x) { add(1, x) }
let b = add(1, _)
echo a(10)
echo b(10)
```

a, b 둘 다 동일한 의미이다.

또 당연하게도 파이프라인 문법이 있다.
`|>` 연산자를 사용하는데 타이핑하기 귀찮을 거 같다는 생각이 먼저 들었다.
어떤 값에서 시작해서 그 값을 다음 함수의 첫번째 인자로 넣어준다.

```gleam
1
|> add(2)
|> multiply(2)
|> int.to_string
|> io.println
```

이런 느낌.

함수 호출 시 파라미터 이름을 따로 지정해줄 수 있는데 이 기능 자체는 다른 언어에도 흔하지만 조금 특이한 점이 있다.
따로 지정할 이 이름, 즉 라벨을 따로 명명해줘야 한다는 것.

```gleam
fn add(lhs a: Int, rhs b: Int) -> Int {
  a + b
}

add(lhs: 1, rhs: 2)
```

함수 호출시 넘길 값을 담은 변수의 이름과 이 라벨의 이름이 같으면 다음과 같이 할 수도 있다.

```gleam
let lhs = 1
let rhs = 2
echo add(lhs:, rhs:)
```

솔직히 마음엔 안 든다.

튜플을 `#(...)` 이렇게 선언하는 것도 사소하게 기억에 남지만 좀 장황한 느낌이 있다.

다른 언어의 enum, struct 같은 걸 Rust식 enum 하나로 퉁친 것도 기억에 남는다.
그냥 구조체 하나 정의하려면 다음과 같이 한다.

```gleam
type Person {
  Person(name: String, age: Int)
}

let p = Person(name: "W", age: 4)
```

항목을 더 추가하면 그대로 enum처럼 된다.

Bit arrays라는 희한한 문법도 있는데 이건 쓸 일이 있을까 싶긴 했다.

콜백 지옥이 되는 걸 피하기 위한 독특한 use 문법이 있던데 이런 건 처음 봐서 그러겠지만 좀 비직관적인 거 같다는 생각이 들긴 했다.

```gleam
// Use 없을 경우:
result.try(get_name(), fn(name) {
  result.try(get_password(), fn(pwd) {
    result.map(log_in(name, pwd), fn(result) {
      echo result
    })
  })
})

// Use 쓸 경우:
use name <- result.try(get_name())
use pwd <- result.try(get_password())
use result <- result.map(log_in(name, pwd))
echo result
```

이 정도 기억에 남는다.

이걸로 뭔가 하나 만들어보면 좋을텐데 뭐가 좋을까...
백엔드 쪽에서 주로 쓰는 언어라고 하니 서버를 뭔가 만들어야 하나...